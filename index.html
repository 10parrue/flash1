<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Citation</title>
  <meta http-equiv="Cache-Control" content="no-store, max-age=0" />
  <style>
    :root{
      --bg: #f8f4e6;     /* beige papier */
      --ink:#002fa7;     /* Bleu Klein */
      --pad: clamp(16px, 5vw, 36px);
      --boxw: min(900px, 94vw);
      --radius: 12px;
    }
    html, body {
      margin: 0; padding: 0; min-height: 100vh;
      background: var(--bg); color: var(--ink);
      font-family: "Courier New", monospace;
    }
    body {
      padding:
        calc(env(safe-area-inset-top, 0px))
        calc(env(safe-area-inset-right, 0px))
        calc(env(safe-area-inset-bottom, 0px))
        calc(env(safe-area-inset-left, 0px));
      display: grid; place-items: center;
    }
    .card {
      width: var(--boxw);
      max-width: var(--boxw);
      max-height: calc(100vh - 8vh); /* marges verticales */
      padding: var(--pad);
      background: rgba(255,255,255,.85);
      border: 1px solid #e0d8c3;
      border-radius: var(--radius);
      box-shadow: 0 8px 28px rgba(0,0,0,.08);
      display: grid; place-items: center;
      overflow: hidden;
    }
    #quote {
      text-align: center;
      line-height: 1.6;
      word-break: break-word;
      overflow-wrap: anywhere;
      hyphens: auto;
      /* font-size défini par JS (fit) */
    }
    #quote p { margin: 0 0 .8em; }
    #quote p:last-child { margin-bottom: 0; }
  </style>
</head>
<body>
  <div class="card">
    <div id="quote">Chargement…</div>
  </div>

  <script>
    /* ---------- Config ---------- */
    const GDOC_URL    = "https://docs.google.com/document/d/1xbEENkpFDplLEj9UxB1D052luBngxXlv71Lb4bm9-14/export?format=txt";
    const STORAGE_KEY = "citation_unique_zoom_fit_v2";
    const SEPARATOR   = "---";        // sépare les citations
    // 1x § = saut de ligne ; 2x (ou +) § = nouveau paragraphe
    const RE_PARA_SPLIT = /\s*§{2,}\s*/g;
    const RE_LINE_SPLIT = /\s*§\s*/g;

    /* ---------- Utilitaires ---------- */
    const pickRandom = arr => arr[Math.floor(Math.random() * arr.length)];
    const escapeHtml = s => s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));

    function renderFromSectionMarkers(plain){
      const paras = plain.split(RE_PARA_SPLIT).map(s => s.trim()).filter(Boolean);
      const htmlParas = paras.map(p => {
        const lines = p.split(RE_LINE_SPLIT).map(x => escapeHtml(x.trim())).filter(Boolean);
        return `<p>${lines.join("<br>")}</p>`;
      });
      return htmlParas.join("");
    }

    async function fetchDocText(){
      const res  = await fetch(GDOC_URL, { cache: "no-store", credentials: "omit" });
      const text = await res.text();
      // Nettoyage doux (on ne touche pas à § ni à ---)
      return text
        .replace(/\u00A0/g, " ")        // nbsp → espace
        .replace(/[ \t\f\v]{2,}/g, " ") // compresse espaces consécutifs
        .trim();
    }

    /* ---------- Fit (zoom adaptatif) ---------- */
    function fitTextToContainer(el, container, {minPx=18, maxPx=42, step=0.5} = {}){
      let lo = minPx, hi = maxPx, best = minPx;
      const fits = (px) => {
        el.style.fontSize = px + "px";
        return el.scrollHeight <= container.clientHeight && el.scrollWidth <= container.clientWidth;
      };
      for (let i = 0; i < 20; i++) {
        const mid = Math.round((lo + hi) / 2 / step) * step;
        if (mid === lo || mid === hi) break;
        if (fits(mid)) { best = mid; lo = mid; } else { hi = mid; }
      }
      while (!(el.scrollHeight <= container.clientHeight && el.scrollWidth <= container.clientWidth) && best > minPx){
        best = Math.max(minPx, best - step);
        el.style.fontSize = best + "px";
      }
      el.style.fontSize = Math.max(minPx, best - 0.5) + "px";
    }

    function scheduleFit(){
      clearTimeout(scheduleFit._t);
      scheduleFit._t = setTimeout(() => {
        requestAnimationFrame(() => {
          const card = document.querySelector(".card");
          const quote = document.getElementById("quote");
          if (!quote.innerHTML) return;
          fitTextToContainer(quote, card, {minPx:18, maxPx:42, step:0.5});
        });
      }, 30);
    }

    /* ---------- Init ---------- */
    async function init(){
      try{
        const el = document.getElementById('quote');

        // Même citation au refresh (par onglet)
        const cached = sessionStorage.getItem(STORAGE_KEY);
        if (cached) {
          el.innerHTML = cached;
          scheduleFit();
          return;
        }

        const all = await fetchDocText();
        const parts = all.split(/\s*---\s*/g).map(s => s.trim()).filter(Boolean);
        if (!parts.length) throw new Error("Aucune citation détectée (séparateur --- manquant).");

        const picked    = pickRandom(parts);
        const finalHtml = renderFromSectionMarkers(picked);

        sessionStorage.setItem(STORAGE_KEY, finalHtml);
        el.innerHTML = finalHtml;

        scheduleFit();
      }catch(e){
        document.getElementById('quote').innerHTML =
          "Impossible de charger les citations.<br><small>" + (e?.message || e) + "</small>";
      }
    }

    document.addEventListener('DOMContentLoaded', init);
    window.addEventListener('resize', scheduleFit, {passive:true});
    window.addEventListener('orientationchange', scheduleFit, {passive:true});
    try { new ResizeObserver(scheduleFit).observe(document.querySelector('.card')); } catch(_) {}
    document.fonts?.ready?.then(scheduleFit);
  </script>
</body>
</html>
